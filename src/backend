from flask import Flask, request, jsonify
from flask_babel import Babel, _
import music21
import librosa
import numpy as np
import magenta
import tensorflow as tf
from magenta.models.drums_rnn import drums_rnn_sequence_generator

app = Flask(__name__)

# Configuración de Flask-Babel para soporte multilingüe
app.config['BABEL_DEFAULT_LOCALE'] = 'es'
app.config['BABEL_DEFAULT_TIMEZONE'] = 'UTC'
babel = Babel(app)

@babel.localeselector
def get_locale():
    lang = request.json.get('lang', 'es') if request.is_json else 'es'
    supported_langs = ['es', 'he', 'en', 'pt', 'fr', 'it', 'ja', 'ko']
    return lang if lang in supported_langs else 'es'

# Cargar modelo de Magenta para generación de ritmos
bundle = magenta.music.sequence_generator_bundle.read_bundle_file('models/drumm_rnn_model/drumm_rnn.mag')
generator = drums_rnn_sequence_generator.DrumsRnnSequenceGenerator()
generator.initialize()

# Cargar modelo de clasificación de instrumentos (simulado)
instrument_classifier = tf.keras.models.load_model('models/instrument_classifier')

# Endpoint para generar ritmos
@app.route('/generate-rhythm', methods=['POST'])
def generate_rhythm():
    data = request.json
    tempo = data.get('tempo', 120)
    beats = data.get('beats', 4)
    style = data.get('style', 'classical')

    # Usar Magenta para generar un ritmo
    drum_track = generator.generate({}, seconds=beats / (tempo / 60))
    stream = music21.stream.Stream()
    stream.append(music21.tempo.MetronomeMark(number=tempo))
    for event in drum_track.events:
        if event.note:
            stream.append(music21.note.Note('C4', quarterLength=event.duration))

    midi = stream.write('midi', fp='temp.mid')
    return jsonify({
        'rhythm': _(f"Ritmo a {tempo} BPM con {beats} pulsos"),
        'midi': midi,
        'correct_answer': 'ta ' * beats if style == 'classical' else 'ta-ka ta ' * (beats // 2)
    })

# Endpoint para dictado melódico
@app.route('/generate-melodic-dictation', methods=['POST'])
def generate_melodic_dictation():
    data = request.json
    key = data.get('key', 'C major')
    length = data.get('length', 4)

    stream = music21.stream.Stream()
    scale = music21.scale.MajorScale(key)
    notes = scale.getPitches('C4', 'C5')
    melody = [music21.note.Note(np.random.choice(notes)) for _ in range(length)]
    stream.extend(melody)
    midi = stream.write('midi', fp='temp_melody.mid')

    return jsonify({
        'melody': _(f"Melodía en {key} con {length} notas"),
        'midi': midi,
        'correct_answer': ' '.join([n.name for n in melody])
    })

# Endpoint para identificar instrumentos
@app.route('/identify-instruments', methods=['POST'])
def identify_instruments():
    data = request.json
    audio_file = data.get('audio_file', 'data/sample.wav')
    y, sr = librosa.load(audio_file)
    features = librosa.feature.mfcc(y=y, sr=sr)
    prediction = instrument_classifier.predict(features)
    instruments = ['piano', 'drum'][np.argmax(prediction)]

    return jsonify({
        'instruments': instruments,
        'count': len(instruments),
        'message': _(f"Se detectaron {len(instruments)} instrumentos"),
        'correct_answer': ', '.join(instruments)
    })

# Endpoint para teoría musical
@app.route('/get-theory', methods=['POST'])
def get_theory():
    data = request.json
    topic = data.get('topic', 'compás')
    theory = {
        'compás': _("Un compás organiza los tiempos. Ejemplo: 4/4 significa 4 tiempos."),
        'escala': _("Una escala es una secuencia de notas. Ejemplo: C mayor: C, D, E, F, G, A, B, C.")
    }
    return jsonify({
        'theory': theory.get(topic, _("Teoría no encontrada."))
    })

# Endpoint para validar respuestas
@app.route('/check-answer', methods=['POST'])
def check_answer():
    data = request.json
    user_answer = data.get('answer', '').lower().strip()
    correct_answer = data.get('exercise', '').lower().split('correct_answer: ')[1] if 'correct_answer' in data.get('exercise', '') else data.get('correct_answer', '')

    is_correct = user_answer == correct_answer
    return jsonify({
        'feedback': _(f"¡Correcto!" if is_correct else f"Incorrecto. La respuesta correcta es {correct_answer}"),
        'correct': is_correct
    })

if __name__ == '__main__':
    app.run(debug=True, host='0.0.0.0', port=5000)
